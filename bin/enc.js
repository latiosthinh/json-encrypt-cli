#!/usr/bin/env node

// Load environment variables from .env file
require('dotenv').config();

const { program } = require('commander');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const { intro, outro, text, select, confirm, spinner } = require('@clack/prompts');

// Supported encryption algorithms
const ALGORITHMS = {
  'aes-256-cbc': 'AES-256-CBC',
  'aes-192-cbc': 'AES-192-CBC',
  'aes-128-cbc': 'AES-128-CBC',
  'aes-256-gcm': 'AES-256-GCM',
  'aes-192-gcm': 'AES-192-GCM',
  'aes-128-gcm': 'AES-128-GCM'
};

function encryptData(data, algorithm, secretKey) {
  const key = crypto.scryptSync(secretKey, 'salt', algorithm.includes('256') ? 32 : algorithm.includes('192') ? 24 : 16);
  
  if (algorithm.includes('gcm')) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(algorithm, key, iv);
    cipher.setAAD(Buffer.from('json-encrypt', 'utf8'));
    
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    const authTag = cipher.getAuthTag();
    
    return {
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
      encrypted
    };
  } else {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(algorithm, key, iv);
    
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return {
      iv: iv.toString('hex'),
      encrypted
    };
  }
}

function generateDecryptionExample(algorithm, outputPath) {
  const exampleContent = `// Decryption example for ${path.basename(outputPath)}
// Generated by json-encrypt-cli
// Note: Algorithm is hidden in encrypted file for security

import * as crypto from 'crypto';
import * as fs from 'fs';

interface EncryptedData {
  iv: string;
  authTag?: string;
  encrypted: string;
}

function decryptFile(filePath: string, algorithm: string, secretKey: string): any {
  try {
    // Read the encrypted file
    const encryptedData: EncryptedData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
    
    // Generate key using the same method as encryption
    const keyLength = algorithm.includes('256') ? 32 : 
                     algorithm.includes('192') ? 24 : 16;
    const key = crypto.scryptSync(secretKey, 'salt', keyLength);
    
    const iv = Buffer.from(encryptedData.iv, 'hex');
    
    let decrypted: string;
    
    if (algorithm.includes('gcm')) {
      // GCM mode decryption
      const decipher = crypto.createDecipheriv(algorithm, key, iv);
      if (encryptedData.authTag) {
        decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
      }
      decipher.setAAD(Buffer.from('json-encrypt', 'utf8'));
      
      decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
    } else {
      // CBC mode decryption
      const decipher = crypto.createDecipheriv(algorithm, key, iv);
      decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
    }
    
    return JSON.parse(decrypted);
  } catch (error) {
    throw new Error(\`Decryption failed: \${error.message}\`);
  }
}

// Example usage (you must provide the algorithm used for encryption):
// const decryptedData = decryptFile('${path.basename(outputPath)}', '${algorithm}', 'your-secret-key');
// console.log(decryptedData);

export { decryptFile };
`;

  const examplePath = path.join(path.dirname(outputPath), 'decryption.example.ts');
  fs.writeFileSync(examplePath, exampleContent);
  return examplePath;
}

async function interactiveMode(filePath) {
  intro('üîê JSON Encrypt CLI');
  
  // Get defaults from environment variables
  const defaultAlgorithm = process.env.ENC_ALGORITHM || 'aes-256-cbc';
  const defaultSecret = process.env.ENC_SECRET;
  
  // Show current defaults if available
  if (defaultAlgorithm || defaultSecret) {
    console.log('\nüìã Current defaults from .env:');
    if (defaultAlgorithm) console.log(`   Algorithm: ${defaultAlgorithm}`);
    if (defaultSecret) console.log(`   Secret: ${'*'.repeat(Math.min(defaultSecret.length, 20))}`);
    console.log('');
  }
  
  const algorithm = await select({
    message: 'Choose encryption algorithm:',
    initialValue: defaultAlgorithm,
    options: Object.entries(ALGORITHMS).map(([key, value]) => ({
      value: key,
      label: value + (key === defaultAlgorithm ? ' (default)' : '')
    }))
  });
  
  const secretKey = await text({
    message: 'Enter your secret key:',
    placeholder: defaultSecret ? 'Press Enter to use default from .env...' : 'Enter a strong secret key...',
    defaultValue: defaultSecret || '',
    validate: (value) => {
      if (!value || value.length < 8) {
        return 'Secret key must be at least 8 characters long';
      }
    }
  });
  
  const shouldGenerateExample = await confirm({
    message: 'Generate decryption example file?',
    initialValue: true
  });
  
  return { algorithm, secretKey, shouldGenerateExample };
}

async function encryptFile(filePath, algorithm, secretKey, generateExample = true) {
  const s = spinner();
  
  try {
    s.start('Reading JSON file...');
    
    if (!fs.existsSync(filePath)) {
      throw new Error(`File not found: ${filePath}`);
    }
    
    const jsonData = fs.readFileSync(filePath, 'utf8');
    
    // Validate JSON
    try {
      JSON.parse(jsonData);
    } catch (error) {
      throw new Error('Invalid JSON file');
    }
    
    s.message('Encrypting data...');
    
    const encryptedData = encryptData(jsonData, algorithm, secretKey);
    
    const outputPath = filePath.replace(/\.json$/, '.enc');
    
    s.message('Writing encrypted file...');
    fs.writeFileSync(outputPath, JSON.stringify(encryptedData, null, 2));
    
    let examplePath = null;
    if (generateExample) {
      s.message('Generating decryption example...');
      examplePath = generateDecryptionExample(algorithm, outputPath);
    }
    
    s.stop('‚úÖ Encryption completed successfully!');
    
    console.log(`\nüìÅ Encrypted file: ${outputPath}`);
    if (examplePath) {
      console.log(`üìÑ Decryption example: ${examplePath}`);
    }
    
  } catch (error) {
    s.stop('‚ùå Encryption failed!');
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
}

// CLI setup
program
  .name('enc')
  .description('Encrypt JSON files with various algorithms')
  .version('1.0.0');

program
  .argument('<file>', 'Path to JSON file to encrypt')
  .option('--alg <algorithm>', 'Encryption algorithm')
  .option('--secret <key>', 'Secret key for encryption')
  .option('--no-example', 'Skip generating decryption example')
  .action(async (file, options) => {
    const filePath = path.resolve(file);
    
    // Get defaults from environment variables
    const defaultAlgorithm = process.env.ENC_ALGORITHM || 'aes-256-cbc';
    const defaultSecret = process.env.ENC_SECRET;
    
    // Use provided options or fall back to environment defaults
    const algorithm = options.alg || defaultAlgorithm;
    const secret = options.secret || defaultSecret;
    
    if (secret && algorithm) {
      // Command line mode (with env defaults if needed)
      if (!ALGORITHMS[algorithm]) {
        console.error(`‚ùå Unsupported algorithm: ${algorithm}`);
        console.log('Supported algorithms:', Object.keys(ALGORITHMS).join(', '));
        process.exit(1);
      }
      
      // Show what defaults were used
      if (!options.alg && process.env.ENC_ALGORITHM) {
        console.log(`üìã Using algorithm from .env: ${algorithm}`);
      }
      if (!options.secret && process.env.ENC_SECRET) {
        console.log(`üìã Using secret from .env: ${'*'.repeat(Math.min(secret.length, 20))}`);
      }
      
      await encryptFile(filePath, algorithm, secret, options.example);
    } else {
      // Interactive mode
      const { algorithm, secretKey, shouldGenerateExample } = await interactiveMode(filePath);
      await encryptFile(filePath, algorithm, secretKey, shouldGenerateExample);
      outro('üéâ Done! Your JSON file has been encrypted.');
    }
  });

program.parse();